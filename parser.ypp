%require "3.8.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace

%code requires
{
    #pragma once
    #include <iostream>
    #include <string>
		#define YYDEBUG 1

		using namespace std;
    
    // forward decleration (1)
    namespace yy
    {
        class parser;
    }
}
%code
{
    namespace yy
    {
        parser::symbol_type yylex(); // override (2)
        // no need to override the error function because it is already waiting for our implementation (3)
    }

    extern yy::parser::symbol_type get_next_token();
}

%token <std::string> IDENTIFIER
%token <std::string> NUMBER
%token <std::string> STRING
%token BOOL
%token VAR
%token CONST
%token IS
%token NUMBER_TYPE
%token STRING_TYPE
%token BOOL_TYPE
%token NULL_TYPE
%token COMMA
%token SEMICOLON
%token ASSIGN
%token PLUS
%token MINUS
%token MUL
%token DIV
%token LPAREN
%token RPAREN
%token EOF_
%token LBRACKET
%token RBRACKET
%token LBRACE
%token RBRACE
%token READ_INT
%token READ_REAL
%token READ_STRING
%token PRINT
%token IF
%token ELSE
%token THEN
%token END
%token LESS
%token LESS_E
%token GREATER
%token GREATER_E
%token EQUAL
%token NOT_EQUAL
%token NOT
%token WHILE_L
%token FOR_L
%token LOOP
%token FUNC
%token RETURN
%token DO
%token DOT_OP
%token INVALID
%token AND
%token OR
%token XOR

%left AND OR
%left NOT
%nonassoc LESS GREATER LESS_E GREATER_E EQUAL
%left MINUS PLUS
%left MUL DIV

%%

program: /* empty */
	| block EOF_
	;

block
	: statement
	| operation
	| block statement {  }
	| block operation
	;

statement
	: assignment
	| if_statement
	| loop_statement
	| function_call
	;


assignment
	: list_assignemtns SEMICOLON { std::cout << "reassign;" << "\n"; }
	| declaration_specifics list_assignemtns SEMICOLON { std::cout << "declaration;" << '\n'; }
	| declaration_specifics IDENTIFIER ASSIGN function_declaration { cout << "declaration;\n"; }
	;

declaration_specifics
	: VAR
	| CONST;

list_assignemtns
	: list_assignemtns COMMA assignment_part
	| assignment_part { cout << "assignment right part\n"; }
	;

assignment_part
	: IDENTIFIER ASSIGN assignment_value
	| IDENTIFIER ASSIGN expression
	| IDENTIFIER /* empty */
	;

assignment_value
	: NULL_TYPE
	| BOOL
	| LBRACKET RBRACKET
	| NUMBER
	| STRING
	| function_call
	| LBRACE list_assignemtns RBRACE
	| LBRACKET function_params RBRACKET
	;

tuple_element
	: IDENTIFIER DOT_OP IDENTIFIER
	| IDENTIFIER DOT_OP NUMBER
	;

assignment_type
	: NULL_TYPE
	| BOOL_TYPE
	| NUMBER_TYPE
	| STRING_TYPE
	;

expression
	: term
	| expression PLUS term
	| expression MINUS term
	| LPAREN expression RPAREN
	;

term
	: factor
	| term MUL factor
	| term DIV factor
	;

factor
	: NUMBER
	| STRING
	| BOOL
	| IDENTIFIER
	| function_call
	| tuple_element
	| IDENTIFIER LBRACKET NUMBER RBRACKET
	| IDENTIFIER IS assignment_type
	;


operation
	: keyword expression SEMICOLON { cout << "keyword expression;\n"; }
	| IDENTIFIER operation_op ASSIGN assignment_value SEMICOLON
	| tuple_element operation_op ASSIGN assignment_value SEMICOLON
	| IDENTIFIER LBRACKET NUMBER RBRACKET ASSIGN assignment_value SEMICOLON
	;

operation_op
	: PLUS
	| MINUS
	| MUL
	| DIV
	;

keyword
	: READ_INT
	| READ_REAL
	| READ_STRING
	| PRINT

if_statement
	: IF conditional_expression THEN block if_alternatives END
	;

conditional_expression 
	: conditional_expression AND conditional_expression
	| conditional_expression OR conditional_expression
	| NOT conditional_expression
	| expression LESS expression { cout << "a < 5\n";}
	| expression LESS_E expression
	| expression GREATER expression
	| expression GREATER_E expression
	| expression EQUAL expression
	| expression NOT_EQUAL expression
	| expression
	;

if_alternatives
	: /* empty */
	| ELSE block
	| ELSE IF conditional_expression THEN block if_alternatives
	;

loop_statement
	: WHILE_L conditional_expression LOOP block END { cout << "while statement;\n"; }
	| FOR_L assignment conditional_expression SEMICOLON for_expression LOOP block END { cout << "for statement;\n"; }
	;

for_expression
	: IDENTIFIER operation_op ASSIGN assignment_value
	;

function_declaration
	: FUNC LPAREN function_params RPAREN DO block RETURN expression SEMICOLON END { cout << "function declaration;\n"; }

function_call
	: IDENTIFIER LPAREN function_params RPAREN { cout << "function call\n"; }

function_params
	: list_assignemtns
	| factor_list
	;

factor_list
	: factor_list COMMA factor
	| factor
	;

%%
int yywrap() {
	return 0;
}

namespace yy
{
    void parser::error(const std::string& msg) //(3+)
    {
        std::cout<< msg << '\n';
    }
}